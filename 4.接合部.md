# 第 4 章 接合モデル

簡単にテストできるプログラムを書くには、

- 開発と並行してテストを作成する　 ★ 重要
- 少し時間をかけて「テストの容易性に配慮した設計」を行う

## 接合部

単体テストのために個々のクラスを取り出そうとすると、たくさんの依存関係を排除する必要がある  
いくら設計が **優れていた**としても、しばしば多くの作業が発生してしまう

```C++
bool CAnsyncSslRec::Init() {
    if (m_bSslInitialized) {
        return true;
    }

    m_smutex.Unlock();
    m_nSslRefCount++;

    m_bSslInitialized = true;

    FreeLibrary(m_hSslD111);
    m_hSs1D111 = 0;

    FreeLibrary(m_hSs1D112);
    m_hSs1D112 = 0;

    if (!m_bFailureSent) {
        m_bFailureSent = TRUE;

        // この行を実行したくない
        // 別のサブシステムとやりとりするグローバルな関数。
        // この関数を呼び出さずにInitメソッドを実行するには？？？？
        // 仮想関数でオーバライド？すると、この振る舞いを事実上無効とすることができる
        PostReceiveError(SOCKETCALLBACK, SSL_FAILURE);
    }

    CreateLibrary(m_hSs1D111, "syncese11.dll");
    CreateLibrary(m_hSs1D112, "syncese11.dll");

    m_hSs1D111->Init();
    m_hSs1D112->Init();

    return true;

}
```

PostReceiveError 関数を呼び出さずに Init メソッドを実行するには？？ -> この考え方が接合部に繋がる  
**接合部**  
その場所を直接修正しなくても、プログラムの振る舞いを変えることのできる場所

```C++
// PostReceiveError関数を呼び出さずにInitメソッドを実行するには？？
// 同じシグネチャを持つメソッドをこのクラスに追加する
class CAsyncSslRec {
    // virtual = 仮想関数というものらしい。。オーバーライドと似ている
    virtual void PostReceiveError(UINT type, UINT errorcode);
}
```

以下を追加

```C++
void CAsyncSslRec::PostReceiveError(UINIT type, UINIT errorcode) {
    // C++の　スコープ解決演算子。PostReceiveErrorに処理を委譲する
    // 最終的には同じグローバル関数を呼び出している
    ::PostReceiveError(type, errorcode);
}
```

```C++
// CAsyncSsleRecのサブクラス
class TestingCAsyncSslRec : public CAsyncSslRec {
    // CAsyncSslRecインスタンスを生成しているところに戻り、
    // CAsyncSslRecインスタンスの代わりに、TestingAsyncSslRecインスタンスを生成する
    virtual void PostReceiveError(UINT type, UINT errorcode) {

    }
}
```

厄介なメソッド(PostReceiveError)をオーバーライドし、振る舞いをなくす。  
**オブジェクト接合部**  
呼び出し側(Init メソッド)を変更することなく、呼び出されるメソッド(PostReceiveError)を変更することができる。

-> なぜ接合部なのか。この概念はどう役に立つのか。  

- 接合部という観点から見ることで、依存関係を排除する手がかりをみつけることができる
- 接合部で振る舞いを置き換えることができれば、テスト時に依存関係を取り除くことができる。
- 依存関係がある部分に対して別のコードを実行させることにより、コード中の条件を調査してそれに対するテストを書くこともできる。

### 接合部の種類

#### プリプロセッサ接合部

**プリプロセッサ**
ほとんどのプログラミング言語 = コンパイラがプログラムの文字列を読み取る。  
コンパイラ -> オブジェクトコードやバイトコード命令を吐き出す。

コンパイル前にビルドの一段階を設けている言語 = C, C++  
コンパイルの前に、プロセッサが動く

```C++
TEST(getBalance, Account) {
    Account account;
    LONGS_EQUAL(0, account.getBalance());
}
```

コンパイラに対して次のように見せることができる

```C++
class AccountgetBalanceTest : public Test
{
    public : AccountgetBalanceTest() : Test ("getBalance" "Test") {}
    void run (TestResult&result_);
}

AccountgetBalanceInstance;

void AccountgetBalanceTest::run (TestResult&result_) {
    Account account;
    {
        result_.countCheck();
        long actualTemp = (account.getBalance());
        long expectedTemp = (0);
        if ((expectedTemp) != (actualTemp)) {
            result_.addFailure(Failure (name_, "/example.cpp", 24, StringFrom(expectedTemp),
            StringFrom(actualTemp)));
            return;
        }
    }
}
```

次のように条件付きコンパイル文の中にコードを埋め込んで、デバッグを行ったり、  
さまざまなプラットフォームをサポート（これが苦労の種）したりすることができる。  

- 本番コードでプリプロセッサを多用するのはよくない -> コードが不明確になりがち
- 条件付きコンパイル指令(#ifdef #ifndef #if)を使うと、複数の異なるプログラムを 1 つのソースコードで保守することとなる

```C++
m_pRtg->Adj(2.0);

#ifdef DEBUG
#ifndef WINDOWS

{
    FILE * fp = fopen(TGLOGNAME, "w");

    if (fp) {
        fprintf(fp, "%s", m_pRtg->pszState);
        fclose(fp);
    }
}
#endif

m_pTSRTable->p_nFlush |= GF_FLOAT;
#endif
```

プリプロセッサの利点 = 接合部を提供する  

```C++
#include <DFHLItem.h>
#include <DHLSRecord.h>

extern int db_update(int, struct DFHLItem *);

/**
* プリプロセッサ接合部を使うと、db_update関数の呼び出しを置き換えることができる。
* localdefs.hというヘッダーファイルを導入
*/
#include "localdefs.h"

void account_update(int account_no, struct DHLSRecord *record, int activated) {
    if (activated) {
        if (recordvz->dateStamped && record->quantity > MAX_ITEMS) {
            // 置き換え
            db_update(account_no, record->item);
        }
    } else {
        // 置き換え
        db_update(account_no, record->backup_item);
    }

    // 置き換え
    db_update(MASTER_ACCOUNT, record->item);
}
```


#include "localdefs.h"
```C++
/**
* db_updateの代替関数と、変数を定義
  許容点
*/
#ifdef TESTING

struct DFHLItem *last_item = NULL;
int last_account_no = -1;

#define db_update(account_no, item)￥
{
    last_item = item(item);

    last_account_no = (account_no);
}

#endif
```
db_update関数が正しいパラメータで呼ばれていることを確認するテスト  
#include指令が、接合部になっていて、それを使ってコードに書かれたテキストをコンパイル前に置き換えられる  
Javaなどには要らない。。  

##### 許容点
接合部 = その場所のコードを直接変えることはできない(コードを変えずとも、テストができるようにする)  
接合部を利用するには、別の場所で変更する必要がある  
TESTINGという名前のプリプロセッサ定義が許容点となる。  
**許容点**
どの接合部も許容点を持つ。  
許容点では、どの振る舞いを使うか決定できる。  

ピンときてないので、これを読む↓↓  
https://twop.agile.esm.co.jp/mastering-seam-for-unit-testing-574bebaadfcf  


#### リンク接合部

#### オブジェクト接合部(接合部で説明しているパターン。重要！)
