# 第3章 検出と分離

## レガシーコードで変更を行う方法
他のクラスになりすまして、影響を直接検出  

1. 検出
   - コードの計算した値にアクセスできない場合、それを検出するために依存関係を排除する
   - 手段・・・**協調クラスの擬装**
2. 分離
   - コードをテストハーネスにいれて実行することすらできない場合、分離するために依存関係を排除する

```Java
public class NetworkBridge {
    /**
    * NetworkBridgeクラスの説明
    * 1. EndPintの配列を受け取り、ローカルのハードウェアを使ってその構成を管理する <- テストをかくには、実際のハードウェアが必要になってしまう
    * 2. ユーザは、NetworkBridgeクラスのメソッドを使い、エンドポイント間のトラフィックの経路を制御する <- 実際にブリッジが何を行っているのか、わからない
    * 3. NetworkBrigeは EndPointの設定を変更することでこの作業を行う
    * 4. EndPointクラスの各インスタンスは、ソケットを開き、ネットワーク経由で特定の装置と通信する
    */
    public void NetworkBrige(EndPoint[] endpoints) {

    }

    public void formRouting(String sourceID, String destID) {
        // hogehogehoge
    }
}

```
3. 接合部

## 協調クラスの擬装
- **擬装オブジェクト**・・・クラスのテストを行うときに、その協調クラスになりすますオブジェクトのこと

### 正しい文字列が表示されるかどうかを確認するにはどうすればよいか
```Java
public class Sale {
    // レジ画面のAPIに対する呼び出しがSaleクラスに埋め込まれていると困難になる
    // コードのどこで画面の更新が行われているか特定できれば、このように設計を変えることができる
    public void scan(barcorde String) {…}
}


// このクラスは、利用している具体的なディスプレイ装置とやり取りするのに必要なコードがすべて含まれている
public class ArtR56Display {
    public void showLine(line String) {…}
}
```

```Java
// リファクタリング後
public class Sale {
    public void scan(barcorde String) {…}
}

public interface Display {
    void showLine(line String);
}

public class Art56Display implements Display {
    public void showLine(line String) {…}
}

// 擬装ディスプレイ
// 利点：それを使ったテストを書いて、Saleクラスが何を行うかを確認できること
public class FakeDisplay implements Display {
    private String listLine;
    
    public String getLastLine() {…}
    public void showLine(line String) {…}
}


```
