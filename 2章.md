# 第2章 フィードバックを得ながらの作業

## システム変更の方法

- 編集して祈る　笑
- 保護して変更する

「ソフトウェアを保護する」＝「テストで保護する」（フィードバックが得られる）

従来の方法  
開発が終わってからテストを作る。  
テストチームがテストを実行し、仕様にあっているか確認する。  
目的＝「正しいことを確認するためのテスト」
<br>
別の目的＝変更を見つけるためのテスト（**回帰テスト**）  
回帰テスト＝定期的にテストを実行して、振る舞いを確認する

## ソフトウェア万力

変更対象の部分に対するテストが存在する＝**ソフトウェア万力**として使うことができる  
振る舞いの大部分を固定し、**意図した箇所しか変更していないことを確認できる**  
変更を見つけるためにテストを用意することは、コードを万力で固定するのと同様の効果がある

## 単体テスト

テストの対象の範囲（粒度）＝コンポーネント  
コンポーネント・・・手続き型は、関数。OCC はクラス。

## 単体テストの条件

- 問題箇所の特定がしやすい
- 0.1 秒以内で終わること
- データベースとやりとりをしない
- ネットワークを介した通信をしない
- ファイルシステムにアクセスしない
- 実行するために特別な環境設定を必要ではない（環境設定ファイルの編集）

##　依存関係の問題
**テストハーネス** ・・・ソフトウェアの一部やコードを動かすために書くテスト用コードを表す一般的な言葉  
変更内容を容易にするために、依存関係を排除する必要がある。 


### 変更したいメソッド
- InvoiceクラスのgetValue()
- InvoiceUpdateResponderのgetResponseText()

### 問題点と解決点
前提：変更するには、InvoiceUpdateResponderクラスとInvoiceクラスのインスタンスを生成できなければならない  
- 問題点1. DBConnectionのインスタンス（DB接続に対する本当の接続）が必要
-> インタフェースを作成し、InvoiceUpdateResponderのコードを変える  


- 問題点2. InvoiceUpdateServletのインスタンスが必要
-> InvoiceUpdateResponderクラスが必要としている情報を渡してあげることで、依存関係を排除する  
-> InvoiceUpdateServletクラスが持っている　InvoiceのIDの集合体  
**パラメータのプリミティブ化** **インターフェースの抽出化**


```Java
public class InvoiceUpdateServlet {
    excute() {}
    buildUpdate()
}

public class DBConnection {
    getInvoices(Criteria) {

    }
}
// 
public class InvoiceUpdateResponder {

    InvoiceUpdateResponder(DBConnection, InvoiceUpdateServlet) {}
    getResponseText() {}　// 変更対象
    update() {}
}
// 
public class Invoice {
    public static str customer;
    public static date date;
    public static duarationOfService int;

    Invoice() {}
    getValue() {} // 変更対象
}
```

**レガシーコードのジレンマ** ・・・　テストを整備するためには、コードを変更する必要がある

### レガシーコードの変更手順
1. 変更点を洗い出す
   - 変更を行う必要のある場所はアーキテクチャによって異なる
   - 第16章、第17章

2. テストを各場所を見つける
   - 第11章、第12章

3. 依存関係を排除する
   - テストの最大の障害＝依存関係
   - テストハーネスでオブジェクトをインスタンス化しにくい、テストハーネスでメソッドを実行しにくい
   - 第23章、第9章、弟10章、第22章、第7章

4. テストを書く
   - レガシーコード用のテストと新規コード用のテストには違いがある
   - 第13章

5. 変更とリファクタリングを行う
   - TDD
   - 第8章、第20章、第21章、第22章


